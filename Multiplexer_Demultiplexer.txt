8*1 MUX

Code:
module mux(y,s,in);
output  y;
input [7:0] in;
input [2:0] s;
reg y;
always @(s)
begin
if(s==3'd0) y=in[0];
else if(s==3'd1) y=in[1];
else if(s==3'd2) y=in[2];
else if(s==3'd3) y=in[3];
else if(s==3'd4) y=in[4];
else if(s==3'd5) y=in[5];
else if(s==3'd6) y=in[6];
else  y=in[7];
end
endmodule

Test Bench:

module mux_tb();
reg [7:0]in;
reg [2:0]s;
wire y;
mux dut(y,s,in);
initial
begin
in=8'b10110110;
s[0]=1'b0;
s[1]=1'b0;
s[2]=1'b0;
end
always #40  s[2]=~s[2];
always #20  s[1]=~s[1];
always #10  s[0]=~s[0];
initial
begin
#200 $finish;
end
endmodule

1*8 DEMUX

Code:

module demux(
    input x,
    input s0,
    input s1,
    input s2,
    output reg [7:0] y
    );
    
    always @(*)
    begin
      y <=8'b00000000;
      case({s2,s1,s0})
      3'b000: begin y[0]<=x; end
      3'b001: begin y[1]<=x; end
      3'b010: begin y[2]<=x; end
      3'b011: begin y[3]<=x; end
      3'b100: begin y[4]<=x; end
      3'b101: begin y[5]<=x; end
      3'b110: begin y[6]<=x; end
      3'b111: begin y[7]<=x; end
      endcase
    end   
endmodule

Test Bench:

module demux_tb();
wire [7:0]y;
reg x,s0,s1,s2;
demux dut(.y(y),.x(x),.s0(s0),.s1(s1),.s2(s2));

initial begin
   x=1'b1;
   s2=1'b0;
   s1=1'b0;
   s0=1'b0;
#10
    x=1'b1;
    s2=1'b0;
    s1=1'b1;
    s0=1'b1;
#10
    x=1'b1;
    s2=1'b1;
    s1=1'b0;
    s0=1'b0;
#10
    x=1'b1;
    s2=1'b1;
    s1=1'b1;
    s0=1'b1;
#10 
$finish;
end
endmodule